config {
   type: "incremental",
   bigquery: {
     partitionBy: "TIMESTAMP_TRUNC(session_start_time, DAY)",
     requirePartitionFilter : true
   },
    tags: ["high-frequency"]
}

pre_operations {
  DECLARE insert_time_checkpoint DEFAULT ( SELECT COALESCE(MAX(latest_insert_time),${dataform.projectConfig.vars.backfillTimestamp}) FROM ${self()} WHERE session_start_time IS NOT NULL );
  DECLARE session_start_time_checkpoint DEFAULT ( SELECT COALESCE(MIN(session_start_time),${dataform.projectConfig.vars.backfillTimestamp}) FROM ${ref("dfcx_transcript")} WHERE session_start_time IS NOT NULL AND insert_time > insert_time_checkpoint );
  CREATE TEMP TABLE sessions_to_update AS (
        SELECT DISTINCT session_id
        FROM ${ref("dfcx_transcript")}
        WHERE session_start_time >= session_start_time_checkpoint AND insert_time > insert_time_checkpoint
  );
  DELETE FROM ${self()} WHERE session_start_time >= session_start_time_checkpoint AND session_id IN (SELECT session_id FROM sessions_to_update);
}

WITH 

defined_head_intents AS (
  SELECT intent_name as head_intent FROM ${ref("intents")} WHERE head_intent = TRUE
),

defined_non_self_service_tasks AS (
  SELECT 'Default Start Flow' as task_display_name
),

base_data AS (
    SELECT
        *,
        -- Flag if this turn matches a defined head intent
        CASE WHEN intent_display_name IN (SELECT head_intent FROM defined_head_intents)
             THEN intent_display_name
             ELSE NULL
        END AS detected_head_intent
    FROM ${ref("dfcx_transcript")}
    WHERE session_start_time >= session_start_time_checkpoint
    AND session_id IN (SELECT session_id FROM sessions_to_update) 
),

interaction_grouping AS (
    SELECT
        session_start_time,
        project_id,
        location,
        agent_id,
        session_id,
        request_time,
        detected_head_intent,
        -- Calculate a raw group ID based on cumulative count of head intents
        COUNT(detected_head_intent) OVER (PARTITION BY session_id ORDER BY request_time ASC) AS raw_group_id
    FROM base_data
),

interaction_ids AS (
    SELECT
        *,
        -- Force turns occurring before the first head intent (raw_group_id = 0) into the first interaction (1)
        GREATEST(1, raw_group_id) AS interaction_position
    FROM interaction_grouping
),

interaction_base AS (
    SELECT
        session_start_time,
        project_id,
        location,
        agent_id,
        session_id,
        interaction_position,
        -- The head intent for the interaction is the one that started it (min request time with a non-null intent in this group)
        ARRAY_AGG(detected_head_intent IGNORE NULLS ORDER BY request_time ASC LIMIT 1)[SAFE_OFFSET(0)] AS interaction_head_intent,
        MIN(request_time) AS start_interaction_time,
        MAX(request_time) AS end_interaction_time
    FROM interaction_ids
    GROUP BY 1, 2, 3, 4, 5, 6
),

-- Flatten all actions to track Task (Flow/Playbook) Start/End events
flattened_task_events AS (
    SELECT
        t.session_id,
        t.request_time,
        COALESCE(action.playbook_name, action.action_flow_display_name) AS task_display_name,
        CASE 
            WHEN action.playbook_name IS NOT NULL THEN TRUE
            WHEN action.action_page_display_name = 'Start Page' THEN TRUE 
            ELSE FALSE 
        END AS is_task_start,
        CASE 
            WHEN action.playbook_name IS NOT NULL THEN TRUE
            WHEN action.action_page_display_name = 'Success' THEN TRUE 
            ELSE FALSE 
        END AS is_task_success,
        action.action_start_time
    FROM base_data t,
        UNNEST(blocks) AS block,
        UNNEST(block.actions) AS action
    WHERE COALESCE(action.playbook_name, action.action_flow_display_name) NOT IN (SELECT task_display_name FROM defined_non_self_service_tasks)
),

-- Aggregate task events per interaction
interaction_tasks AS (
    SELECT
        ib.session_id,
        ib.interaction_position,
        fte.task_display_name,
        -- Did it start in this interaction?
        LOGICAL_OR(fte.is_task_start) AS action_started,
        MIN(CASE WHEN fte.is_task_start THEN fte.action_start_time END) AS action_started_time,
        -- Did it end (success) in this interaction?
        LOGICAL_OR(fte.is_task_success) AS action_ended,
        MAX(CASE WHEN fte.is_task_success THEN fte.action_start_time END) AS action_ended_time
    FROM interaction_base ib
    JOIN flattened_task_events fte
      ON ib.session_id = fte.session_id
     AND fte.request_time BETWEEN ib.start_interaction_time AND ib.end_interaction_time
    GROUP BY 1, 2, 3
),

session_metadata AS (
    SELECT DISTINCT
        session_id,
        MAX(insert_time) as latest_insert_time
    FROM base_data
    GROUP BY 1
)

SELECT
    base.session_start_time,
    base.project_id,
    base.location,
    base.agent_id,
    base.session_id,
    base.interaction_position,
    -- Calculate reverse position
    ROW_NUMBER() OVER (PARTITION BY base.session_id ORDER BY base.interaction_position DESC) AS interaction_position_reverse,
    base.interaction_head_intent,
    base.start_interaction_time,
    base.end_interaction_time,
    -- Construct the nested tasks array
    CASE 
        WHEN ARRAY_LENGTH(ARRAY(
            SELECT AS STRUCT
                task.task_display_name,
                task.action_started,
                task.action_started_time,
                task.action_ended,
                task.action_ended_time
            FROM interaction_tasks task
            WHERE task.session_id = base.session_id
              AND task.interaction_position = base.interaction_position
        )) = 0 THEN 
            [STRUCT(
                'NO_ATTEMPT' AS task_display_name,
                FALSE AS action_started,
                CAST(NULL AS TIMESTAMP) AS action_started_time,
                FALSE AS action_ended,
                CAST(NULL AS TIMESTAMP) AS action_ended_time
            )]
        ELSE 
            ARRAY(
                SELECT AS STRUCT
                    task.task_display_name,
                    task.action_started,
                    task.action_started_time,
                    task.action_ended,
                    task.action_ended_time
                FROM interaction_tasks task
                WHERE task.session_id = base.session_id
                  AND task.interaction_position = base.interaction_position
            )
    END AS tasks,
    md.latest_insert_time
FROM interaction_base base
LEFT JOIN session_metadata md ON base.session_id = md.session_id
